function [x, u, w] = OFDMmod(data, N, Lc, OF, nullpos)

% function [x, u, w] = OFDMmod(data, N, Lc, OF, nullpos)
%
% Simulates OFDM modulation
% Input: 
%  data    = row vector with (frequency-domain) data to be modulated
%  N       = IFFT size
%  Lc      = length of cyclic prefix, in samples
%  OF      = oversampling factor (sinc pulse shaping)
%  nullpos = vector with indices (within 1:N) of null subcarriers
% The data vector will be zero-padded if necessary in order to construct 
% an integer number of OFDM symbols.
% Output:
%  x = filtered   time domain samples ( OF*(N+Lc) samples per OFDM symbol )
%  u = unfiltered time domain samples ( OF*(N+Lc) samples per OFDM symbol )
%  w = time domain samples            (    (N+Lc) samples per OFDM symbol )

if nargin==4
    K = 0; 
    datapos = [1:N];
else
    K = length(nullpos);                % no. of null subcarriers
    datapos = setdiff([1:N], nullpos);  % indices of data subcarriers
end

Nu = N-K;   % No. of useful subcarriers

%% Format data for IFFT
    % hint: you may want to use 'reshape'
Nsymbols = ceil( length(data) / Nu );

s_n = [data, zeros(1, Nsymbols * Nu - length(data))]; % relleno de 0s

data_blocks = reshape(s_n , Nu, Nsymbols).'; % S to P

si_n = zeros(Nsymbols, N);
si_n(:, datapos) = data_blocks;

%% N-point IFFT operation

% ifft(Y,[],2) devuelve la transformada de Fourier inversa de cada fila.
out_IFFT = ifft(si_n, N, 2);

%% Add Cyclic Prefix

CP = out_IFFT(:, end-Lc+1:end); % cogemos las ultimas Lc mustras
wi_n = [CP, out_IFFT];

%% Parallel to serial
    % hint: you may want to use 'reshape'
w_n = reshape(wi_n.', 1, []);

%% Upsample
w = w_n;
u = zeros(1,OF*length(w));
u(1:OF:end) = w;

P = 150;
gtx = srrc(0, P, OF);
x = filter(gtx,1,u);
